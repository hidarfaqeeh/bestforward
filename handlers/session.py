"""
Session Management Handler - Interactive Telethon session creation
"""
import os
import asyncio
import logging
from typing import Optional, Dict, Any
from aiogram import types
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from telethon import TelegramClient
from telethon.sessions import StringSession
from telethon.errors import (
    PhoneNumberInvalidError, 
    PhoneCodeInvalidError, 
    SessionPasswordNeededError,
    PhoneCodeExpiredError,
    FloodWaitError
)

logger = logging.getLogger(__name__)

class SessionStates(StatesGroup):
    """States for session creation process"""
    WAITING_API_ID = State()
    WAITING_API_HASH = State()
    WAITING_PHONE = State()
    WAITING_CODE = State()
    WAITING_PASSWORD = State()
    SESSION_COMPLETE = State()

class SessionHandler:
    """Handler for interactive session creation"""
    
    def __init__(self, bot_controller):
        self.bot_controller = bot_controller
        self.active_sessions: Dict[int, Dict[str, Any]] = {}
        
    async def handle_session_command(self, message: Message, state: FSMContext):
        """Start interactive session creation process"""
        try:
            user_id = message.from_user.id
            
            # Check current session status
            current_session = os.getenv('STRING_SESSION', '')
            session_status = "ŸÖŸÜÿ™ŸáŸäÿ© ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ‚ùå" if not current_session or len(current_session) < 50 else "ŸÜÿ¥ÿ∑ÿ© ‚úÖ"
            
            welcome_text = f"""üîê ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ŸÑÿ≥ÿ© Telethon ÿ™ŸÅÿßÿπŸÑŸä

üìä ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:
‚Ä¢ STRING_SESSION: {session_status}
‚Ä¢ Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ: {'ŸÖÿÆÿ™ŸÑÿ∑ (Bot API + Userbot)' if session_status == 'ŸÜÿ¥ÿ∑ÿ© ‚úÖ' else 'Bot API ŸÅŸÇÿ∑'}

üöÄ ÿ≥ŸäŸÇŸàŸÖ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿßÿπÿØ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ŸÑÿ≥ÿ© ÿ¨ÿØŸäÿØÿ© ÿÆÿ∑Ÿàÿ© ÿ®ÿÆÿ∑Ÿàÿ©:

1Ô∏è‚É£ API_ID
2Ô∏è‚É£ API_HASH  
3Ô∏è‚É£ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
4Ô∏è‚É£ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ
5Ô∏è‚É£ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± (ÿ•ŸÜ Ÿàÿ¨ÿØÿ™)

üìñ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ API_ID Ÿà API_HASH:
‚Ä¢ ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ: https://my.telegram.org
‚Ä¢ ÿ≥ÿ¨ŸÑ ÿØÿÆŸàŸÑŸÉ ÿ®ÿ±ŸÇŸÖ Ÿáÿßÿ™ŸÅŸÉ
‚Ä¢ ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ API Development Tools
‚Ä¢ ÿ£ŸÜÿ¥ÿ¶ ÿ™ÿ∑ÿ®ŸäŸÇ ÿ¨ÿØŸäÿØ

ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿßŸÑÿ®ÿØÿ°ÿü"""

            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üöÄ ÿ®ÿØÿ° ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©", callback_data="session_start")],
                [InlineKeyboardButton(text="‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="session_cancel")]
            ])
            
            await message.answer(welcome_text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Error in session command: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©")

    async def handle_session_callback(self, callback: CallbackQuery, state: FSMContext):
        """Handle session creation callbacks"""
        try:
            data = callback.data
            user_id = callback.from_user.id
            
            if data == "session_start":
                await self._start_api_id_input(callback, state)
            elif data == "session_cancel":
                await self._cancel_session(callback, state)
            elif data == "session_retry":
                await self._start_api_id_input(callback, state)
                
        except Exception as e:
            logger.error(f"Error in session callback: {e}")
            await callback.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®")

    async def _start_api_id_input(self, callback: CallbackQuery, state: FSMContext):
        """Start API_ID input process"""
        try:
            text = """1Ô∏è‚É£ ÿ£ÿØÿÆŸÑ API_ID

üìù ÿ£ÿ±ÿ≥ŸÑ API_ID ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ ŸÉÿ±ŸÇŸÖ ŸÅŸÇÿ∑
ŸÖÿ´ÿßŸÑ: 12345678

‚ö†Ô∏è ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸàŸÉÿßŸÖŸÑ"""

            await callback.message.edit_text(text)
            await state.set_state(SessionStates.WAITING_API_ID)
            await callback.answer("‚úÖ ÿ£ÿ±ÿ≥ŸÑ API_ID ÿßŸÑÿ¢ŸÜ")
            
        except Exception as e:
            logger.error(f"Error starting API ID input: {e}")
            await callback.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ®ÿØÿ° ÿ•ÿØÿÆÿßŸÑ API_ID")

    async def handle_api_id_input(self, message: Message, state: FSMContext):
        """Handle API_ID input"""
        try:
            user_id = message.from_user.id
            api_id_text = message.text.strip() if message.text else ""
            
            # Validate API_ID
            try:
                api_id = int(api_id_text)
                if api_id <= 0:
                    raise ValueError("Invalid API_ID")
            except ValueError:
                await message.answer("‚ùå API_ID ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠\nŸäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖÿßŸã ÿµÿ≠Ÿäÿ≠ÿßŸã\nŸÖÿ´ÿßŸÑ: 12345678")
                return

            # Store API_ID
            await state.update_data(api_id=api_id)
            
            text = """2Ô∏è‚É£ ÿ£ÿØÿÆŸÑ API_HASH

üìù ÿ£ÿ±ÿ≥ŸÑ API_HASH ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ
ŸÖÿ´ÿßŸÑ: 1234567890abcdef1234567890abcdef

‚ö†Ô∏è Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÜÿµ ŸÖŸÜ 32 ÿ≠ÿ±ŸÅ"""

            await message.answer(text)
            await state.set_state(SessionStates.WAITING_API_HASH)
            
        except Exception as e:
            logger.error(f"Error handling API_ID input: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© API_ID")

    async def handle_api_hash_input(self, message: Message, state: FSMContext):
        """Handle API_HASH input"""
        try:
            user_id = message.from_user.id
            api_hash = message.text.strip() if message.text else ""
            
            # Validate API_HASH
            if not api_hash or len(api_hash) != 32:
                await message.answer("‚ùå API_HASH ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠\nŸäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 32 ÿ≠ÿ±ŸÅ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑\nŸÖÿ´ÿßŸÑ: 1234567890abcdef1234567890abcdef")
                return

            # Store API_HASH
            await state.update_data(api_hash=api_hash)
            
            text = """3Ô∏è‚É£ ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ

üìù ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ Ÿáÿßÿ™ŸÅŸÉ ŸÖÿπ ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ©
ŸÖÿ´ÿßŸÑ: +967771234567

‚ö†Ô∏è ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸàŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿ≠ÿ≥ÿßÿ® ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ"""

            await message.answer(text)
            await state.set_state(SessionStates.WAITING_PHONE)
            
        except Exception as e:
            logger.error(f"Error handling API_HASH input: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© API_HASH")

    async def handle_phone_input(self, message: Message, state: FSMContext):
        """Handle phone number input and send verification code"""
        try:
            user_id = message.from_user.id
            phone = message.text.strip() if message.text else ""
            
            # Validate phone number
            if not phone.startswith('+') or len(phone) < 10:
                await message.answer("‚ùå ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠\nŸäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ®ÿØÿ£ ÿ®ŸÄ + ŸàŸäÿ™ÿ∂ŸÖŸÜ ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ©\nŸÖÿ´ÿßŸÑ: +967771234567")
                return

            # Get stored data
            data = await state.get_data()
            api_id = data.get('api_id')
            api_hash = data.get('api_hash')
            
            # Create Telethon client and send code
            try:
                client = TelegramClient(StringSession(), api_id, api_hash)
                await client.connect()
                
                # Send verification code
                result = await client.send_code_request(phone)
                phone_code_hash = result.phone_code_hash
                
                # Store session data
                self.active_sessions[user_id] = {
                    'client': client,
                    'phone': phone,
                    'phone_code_hash': phone_code_hash,
                    'api_id': api_id,
                    'api_hash': api_hash
                }
                
                await state.update_data(phone=phone, phone_code_hash=phone_code_hash)
                
                text = f"""4Ô∏è‚É£ ÿ£ÿØÿÆŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ

üì± ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ŸÑŸâ: {phone}

üìù ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸàÿØ ÿ®ÿ•ÿ≠ÿØŸâ ÿßŸÑÿ∑ÿ±ŸÇ ÿßŸÑÿ™ÿßŸÑŸäÿ©:
‚Ä¢ ÿßŸÑŸÉŸàÿØ ŸÖÿ®ÿßÿ¥ÿ±ÿ©: 12345
‚Ä¢ ŸÖÿπ ÿ≠ÿ±ŸàŸÅ ÿ•ÿ∂ÿßŸÅŸäÿ©: 12345tt (ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©)

üí° ŸÜÿµŸäÿ≠ÿ© ŸÖŸáŸÖÿ©: ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÜÿ≥ŸäŸÇ ŸÖÿ´ŸÑ 12345tt ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÜÿ™Ÿáÿßÿ° ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÉŸàÿØ ÿπŸÜÿØ ÿ•ÿ±ÿ≥ÿßŸÑŸá ŸÅŸä ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ

‚ö†Ô∏è ÿßŸÑŸÉŸàÿØ ŸÖŸÉŸàŸÜ ŸÖŸÜ 5 ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑"""

                await message.answer(text)
                await state.set_state(SessionStates.WAITING_CODE)
                
            except PhoneNumberInvalidError:
                await message.answer("‚ùå ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠\nÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ Ÿàÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ©")
            except FloodWaitError as e:
                await message.answer(f"‚ùå Ÿäÿ¨ÿ® ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± {e.seconds} ÿ´ÿßŸÜŸäÿ© ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ")
            except Exception as e:
                logger.error(f"Error sending verification code: {e}")
                await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ\nÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© API_ID Ÿà API_HASH")
                
        except Exception as e:
            logger.error(f"Error handling phone input: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ")

    async def handle_code_input(self, message: Message, state: FSMContext):
        """Handle verification code input with special format support"""
        try:
            user_id = message.from_user.id
            raw_code = message.text.strip() if message.text else ""
            
            # Parse special code format (e.g., 72737tt -> 72737)
            code = self._parse_verification_code(raw_code)
            
            # Validate parsed code
            if not code or not code.isdigit() or len(code) != 5:
                await message.answer("""‚ùå ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠

üìù ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸàÿØ ÿ®ÿ•ÿ≠ÿØŸâ ÿßŸÑÿ∑ÿ±ŸÇ:
‚Ä¢ ŸÖÿ®ÿßÿ¥ÿ±ÿ©: 12345
‚Ä¢ ŸÖÿπ ÿ≠ÿ±ŸàŸÅ ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©: 12345xx ÿ£Ÿà 12345tt

‚ö†Ô∏è ÿßŸÑŸÉŸàÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 5 ÿ£ÿ±ŸÇÿßŸÖ""")
                return

            # Get session data
            session_data = self.active_sessions.get(user_id)
            if not session_data:
                await message.answer("‚ùå ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\nÿßÿ®ÿØÿ£ ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ®ÿ£ŸÖÿ± /session")
                await state.clear()
                return

            client = session_data['client']
            phone = session_data['phone']
            phone_code_hash = session_data['phone_code_hash']
            
            try:
                # Sign in with code
                await client.sign_in(phone=phone, code=code, phone_code_hash=phone_code_hash)
                
                # Generate string session
                string_session = client.session.save()
                
                await self._save_and_complete_session(message, state, string_session, user_id)
                
            except SessionPasswordNeededError:
                text = """üîê ŸÖÿ∑ŸÑŸàÿ® ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ®ÿÆÿ∑Ÿàÿ™ŸäŸÜ

üìù ÿ£ÿ±ÿ≥ŸÑ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ®ÿÆÿ∑Ÿàÿ™ŸäŸÜ ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÉ

‚ö†Ô∏è Ÿáÿ∞Ÿá ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ™Ÿä ÿ£ŸÜÿ¥ÿ£ÿ™Ÿáÿß ŸÅŸä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ ÿ®ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ"""

                await message.answer(text)
                await state.set_state(SessionStates.WAITING_PASSWORD)
                
            except PhoneCodeInvalidError:
                retry_text = f"""‚ùå ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ {code} ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠

üí° ŸÜÿµÿßÿ¶ÿ≠:
‚Ä¢ ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿµÿ≠Ÿäÿ≠
‚Ä¢ ÿ¨ÿ±ÿ® ÿ™ŸÜÿ≥ŸäŸÇ ŸÖÿÆÿ™ŸÑŸÅ: {code}xx ÿ£Ÿà {code}tt
‚Ä¢ ÿßÿ∑ŸÑÿ® ŸÉŸàÿØ ÿ¨ÿØŸäÿØ ÿ•ÿ∞ÿß ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©

üîÑ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸàÿØ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßÿ®ÿØÿ£ ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ®ŸÄ /session"""
                
                await message.answer(retry_text)
                
            except PhoneCodeExpiredError:
                await message.answer("""‚ùå ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ

üîÑ ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿ¨ŸÑÿ≥ÿ© ÿ¨ÿØŸäÿØÿ©:
‚Ä¢ ÿßÿ≥ÿ™ÿÆÿØŸÖ /session ŸÑŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ
‚Ä¢ ÿ≥ÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÉŸàÿØ ÿ™ÿ≠ŸÇŸÇ ÿ¨ÿØŸäÿØ

üí° ŸÜÿµŸäÿ≠ÿ©: ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÜÿ≥ŸäŸÇ ŸÖÿ´ŸÑ 12345xx ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©""")
                await self._cleanup_session(user_id)
                await state.clear()
                
            except Exception as e:
                logger.error(f"Error signing in with code: {e}")
                await message.answer(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ\nÿßŸÑŸÉŸàÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {code}\nÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÉŸàÿØ Ÿàÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ")
                
        except Exception as e:
            logger.error(f"Error handling code input: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ")

    def _parse_verification_code(self, raw_code: str) -> str:
        """Parse verification code from various formats"""
        if not raw_code:
            return ""
            
        # Remove all non-digit characters except at the end
        # Support formats like: 12345xx, 12345tt, 12345abc, etc.
        import re
        
        # Extract digits from the beginning
        match = re.match(r'^(\d+)', raw_code)
        if match:
            return match.group(1)
            
        return ""

    async def handle_password_input(self, message: Message, state: FSMContext):
        """Handle 2FA password input"""
        try:
            user_id = message.from_user.id
            password = message.text.strip() if message.text else ""
            
            # Get session data
            session_data = self.active_sessions.get(user_id)
            if not session_data:
                await message.answer("‚ùå ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\nÿßÿ®ÿØÿ£ ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ®ÿ£ŸÖÿ± /session")
                await state.clear()
                return

            client = session_data['client']
            
            try:
                # Sign in with password
                await client.sign_in(password=password)
                
                # Generate string session
                string_session = client.session.save()
                
                await self._save_and_complete_session(message, state, string_session, user_id)
                
            except Exception as e:
                logger.error(f"Error signing in with password: {e}")
                await message.answer("‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©\nÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ")
                
        except Exception as e:
            logger.error(f"Error handling password input: {e}")
            await message.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±")

    async def _save_and_complete_session(self, message: Message, state: FSMContext, string_session: str, user_id: int):
        """Save session and complete the process"""
        saved_messages_status = "‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜÿ≥ÿÆÿ© ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©"
        
        # Send session to user's Saved Messages first
        try:
            session_data = self.active_sessions.get(user_id)
            if session_data and 'client' in session_data:
                client = session_data['client']
                if client and client.is_connected():
                    from datetime import datetime
                    session_message = f"""üîë ÿ¨ŸÑÿ≥ÿ© Telethon ÿßŸÑÿ¨ÿØŸäÿØÿ©

üÜî ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user_id}
üìÖ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üìã STRING_SESSION:
```
{string_session}
```

‚ö†Ô∏è ÿßÿ≠ÿ™ŸÅÿ∏ ÿ®Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÅŸä ŸÖŸÉÿßŸÜ ÿ¢ŸÖŸÜ ŸàŸÑÿß ÿ™ÿ¥ÿßÿ±ŸÉŸáÿß ŸÖÿπ ÿ£ÿ≠ÿØ!

ü§ñ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿáÿß ÿ®Ÿàÿßÿ≥ÿ∑ÿ©: Telegram Forwarding Bot"""
                    
                    await client.send_message('me', session_message)
                    logger.info(f"Session sent to Saved Messages for user {user_id}")
                    saved_messages_status = "‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜÿ≥ÿÆÿ© ÿ•ŸÑŸâ ÿ±ÿ≥ÿßÿ¶ŸÑŸÉ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©"
                    
        except Exception as e:
            logger.warning(f"Could not send session to Saved Messages: {e}")
        
        # Send success message
        try:
            success_text = f"""‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ®ŸÜÿ¨ÿßÿ≠!

üîë ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ
{saved_messages_status}

üì± ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÉÿßŸÖŸÑ ÿ•ŸÖŸÉÿßŸÜŸäÿßÿ™Ÿá

üîÑ ÿ≥Ÿäÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™ ŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©

‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±: 
‚Ä¢ ŸÑÿß ÿ™ÿ¥ÿßÿ±ŸÉ Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÖÿπ ÿ£Ÿä ÿ¥ÿÆÿµ
‚Ä¢ ÿßÿ≠ÿ™ŸÅÿ∏ ÿ®Ÿáÿß ŸÅŸä ŸÖŸÉÿßŸÜ ÿ¢ŸÖŸÜ
‚Ä¢ Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ™ÿπÿ∑Ÿä ŸàÿµŸàŸÑ ŸÉÿßŸÖŸÑ ŸÑÿ≠ÿ≥ÿßÿ®ŸÉ"""

            await message.answer(success_text)
            
        except Exception as e:
            logger.error(f"Error sending success message: {e}")
        
        # Send session separately
        try:
            session_text = f"üìã STRING_SESSION (ŸÑŸÑŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä):\n\n{string_session}"
            await message.answer(session_text)
            
        except Exception as e:
            logger.error(f"Error sending session text: {e}")
        
        # Save session securely using session manager
        try:
            from session_manager import get_session_manager
            import os
            
            session_manager = get_session_manager()
            
            # Save to encrypted file with metadata
            metadata = {
                'created_via': 'interactive_session_command',
                'user_id': user_id,
                'timestamp': message.date.isoformat() if message.date else None
            }
            
            if session_manager.save_session(string_session, user_id, metadata):
                logger.success(f"Session saved securely to encrypted file for user {user_id}")
                
                # Also update environment variable for current process
                os.environ['STRING_SESSION'] = string_session
                logger.info("Environment variable updated with new session")
            else:
                logger.error("Failed to save session to encrypted file")
                # Fallback: still update environment variable
                os.environ['STRING_SESSION'] = string_session
                logger.warning("Session saved only to environment variable (fallback)")
            
        except Exception as e:
            logger.error(f"Could not save session securely: {e}")
            # Fallback: update environment variable only
            try:
                import os
                os.environ['STRING_SESSION'] = string_session
                logger.warning("Session saved only to environment variable (fallback)")
            except Exception as env_error:
                logger.error(f"Could not update environment variable: {env_error}")
        
        # Cleanup
        try:
            await self._cleanup_session(user_id)
            await state.clear()
            logger.info(f"Session cleanup completed for user {user_id}")
            
        except Exception as e:
            logger.warning(f"Error during session cleanup: {e}")
        
        logger.info(f"Session creation process completed for user {user_id}")

    async def _cancel_session(self, callback: CallbackQuery, state: FSMContext):
        """Cancel session creation process"""
        try:
            user_id = callback.from_user.id
            await self._cleanup_session(user_id)
            await state.clear()
            
            await callback.message.edit_text("‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©")
            await callback.answer("ÿ™ŸÖ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°")
            
        except Exception as e:
            logger.error(f"Error canceling session: {e}")
            await callback.answer("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°")

    async def _cleanup_session(self, user_id: int):
        """Cleanup active session data"""
        try:
            if user_id in self.active_sessions:
                session_data = self.active_sessions[user_id]
                client = session_data.get('client')
                if client:
                    await client.disconnect()
                del self.active_sessions[user_id]
        except Exception as e:
            logger.error(f"Error cleaning up session: {e}")

    def register_handlers(self, dispatcher):
        """Register session handlers"""
        try:
            # Register state handlers
            dispatcher.message.register(
                self.handle_api_id_input,
                SessionStates.WAITING_API_ID
            )
            
            dispatcher.message.register(
                self.handle_api_hash_input,
                SessionStates.WAITING_API_HASH
            )
            
            dispatcher.message.register(
                self.handle_phone_input,
                SessionStates.WAITING_PHONE
            )
            
            dispatcher.message.register(
                self.handle_code_input,
                SessionStates.WAITING_CODE
            )
            
            dispatcher.message.register(
                self.handle_password_input,
                SessionStates.WAITING_PASSWORD
            )
            
            # Register callback handler
            dispatcher.callback_query.register(
                self.handle_session_callback,
                lambda c: c.data and c.data.startswith('session_')
            )
            
            logger.info("Session handlers registered")
            
        except Exception as e:
            logger.error(f"Error registering session handlers: {e}")